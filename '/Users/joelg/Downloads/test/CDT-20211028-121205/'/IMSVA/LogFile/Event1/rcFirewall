#! /bin/bash
#
# Firewall     Start/Stop built in firewall of IMSVA
#
# chkconfig: 345 90 60
# description: Built in firewall to protect IMSVA device

PATH="/sbin:/bin:/usr/sbin:/usr/bin:/opt/TrendMicro/GoldenGate/bin"
export PATH

PROC_IPTABLES_NAMES=/proc/net/ip_tables_names

trap "" SIGINT SIGTERM
trap "unlock" EXIT

. /etc/lock_functions
. /etc/init.d/functions

lock

FW_RULES=/etc/conf/fw.rules
GLCFG=/opt/TrendMicro/GoldenGate/bin/glcfg.sh
IFENUM=/opt/TrendMicro/GoldenGate/bin/ifenum.sh

update_issue()
{
    /sbin/issueupd.sh
}

get_port_info()
{
    port=`echo $1 | cut -d',' -f1`
    protocol=`echo $1 | cut -d',' -f2`
    mode=`echo $1 | cut -d',' -f3`
}

get_internal_port()
{
    internal_port=`$GLCFG val icp nic`
    internal_ip=`$GLCFG val icp ip`
}

get_data_port()
{
    data_port=`$IFENUM netdev`
    data_port_ip=`$IFENUM netaddr`
}

get_webaccess_status()
{
    web_status=`$GLCFG val firewall webaccess status`
    web_port_info=`$GLCFG val firewall webaccess port`
}

get_sshaccess_status()
{
    ssh_status=`$GLCFG val firewall sshaccess status`
    ssh_port_info=`$GLCFG val firewall sshaccess port`
}

get_postfix_port()
{
    postfix_port_info=`$GLCFG val firewall postfix_port_list port`
}

get_trust_ip_list()
{
    trust_ip_list_num=`$GLCFG val firewall trust_ip_list number`

    trust_ip_list=()
    for i in `seq 1 $trust_ip_list_num`; do
        ip=`$GLCFG val firewall trust_ip_list ip$i`
        trust_ip_list=(${trust_ip_list[@]} $ip)
    done
}

get_port_list()
{
    fix_port_list_num=`$GLCFG val firewall fix_port_list number`

    fix_port_info_list=()
    for i in `seq 1 $fix_port_list_num`; do
        fix_port_info=`$GLCFG val firewall fix_port_list port$i`
        fix_port_info_list=(${fix_port_info_list[@]} $fix_port_info)
    done

    internal_fix_port_info_list=()
    exposed_fix_port_info_list=()
    for i in ${fix_port_info_list[@]}; do
        get_port_info $i
        if [ "$mode" = "I" ]; then
            internal_fix_port_info_list=(${internal_fix_port_info_list[@]} $i)
        elif [ "$mode" = "E" ]; then
            exposed_fix_port_info_list=(${exposed_fix_port_info_list[@]} $i)
        fi
    done

    changeable_port_list_num=`$GLCFG val firewall changeable_port_list number`

    changeable_port_info_list=()
    for i in `seq 1 $changeable_port_list_num`; do
        changeable_port_info=`$GLCFG val firewall changeable_port_list port$i`
        changeable_port_info_list=(${changeable_port_info_list[@]} $changeable_port_info)
    done
    port_info_list=($web_port_info $ssh_port_info $postfix_port_info ${fix_port_info_list[@]} ${changeable_port_info_list[@]})
}

get_network_info()
{
    get_internal_port
    get_data_port
    get_webaccess_status
    get_sshaccess_status
    get_postfix_port
    get_trust_ip_list
    get_port_list
}

set_basic_rules()
{
    # set default policy for table filter
    iptables -P INPUT DROP
    iptables -P OUTPUT ACCEPT
    iptables -P FORWARD ACCEPT

    # flush all rules of all chains in table filter
    iptables -F
    iptables -X

    # allow incoming packs in loopback device
    iptables -A INPUT -i lo -j ACCEPT

    # allow ping
    iptables -A INPUT -p icmp -j ACCEPT
    #disable for CVE-1999-0524
    iptables -A INPUT -p icmp --icmp-type timestamp-request -j DROP
    iptables -A OUTPUT -p icmp --icmp-type timestamp-reply -j DROP
    # allow tracking tcp link
    iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
}

set_basic_rules_v6()
{
    # set default policy for table filter
    ip6tables -P INPUT DROP
    ip6tables -P OUTPUT ACCEPT
    ip6tables -P FORWARD ACCEPT

    # flush all rules of all chains in table filter
    ip6tables -F
    ip6tables -X

    # allow incoming packs in loopback device
    ip6tables -A INPUT -i lo -j ACCEPT

    # allow ping
    ip6tables -A INPUT -p icmpv6 -j ACCEPT

    # allow tracking tcp link
    # ip6tables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
    # There is a problem about the implementation of CentOS on this, so use another way instead
    ip6tables -A INPUT -p tcp ! --syn -j ACCEPT
    
    #Work around for IPv6 firewall issue on Linux kernel 2.6.18 of Openva2.0(Centos5.3)
    #IPv6 firewall on Centos 5.3 doesn't support stateful firewall setting
    #Please refer to https://bugzilla.redhat.com/show_bug.cgi?id=243739
    ip6tables -A INPUT -s ::/0 -d ::/0 -p udp -m udp --sport 53 -j ACCEPT
    ip6tables -A INPUT -s ::/0 -d ::/0 -p udp -m udp --sport 123 -j ACCEPT
}

set_exposed_fix_port_rules()
{
    # set permission for exposed fix ports 
    for i in ${exposed_fix_port_info_list[@]}; do
        get_port_info $i
        for j in $data_port; do
        	iptables -A INPUT -i $j -p $protocol --dport $port -j ACCEPT
        done
    done
}

set_exposed_fix_port_rules_v6()
{
    # set permission for exposed fix ports 
    for i in ${exposed_fix_port_info_list[@]}; do
        get_port_info $i
        for j in $data_port; do
        	ip6tables -A INPUT -i $j -p $protocol --dport $port -j ACCEPT
        done
    done
}

set_web_access_rules()
{
    # set webaccess permission
    get_port_info $web_port_info
    num=`iptables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" | wc -l`
    for i in `seq 1 $num`; do
    	for j in $data_port; do
        	iptables -D INPUT -i $j -p $protocol --dport $port -j ACCEPT > /dev/null 2>&1
        	iptables -D INPUT -i $j -p $protocol --dport $port -j DROP > /dev/null 2>&1
        done
    done

    if [ "$web_status" = "all" ]; then
    	for i in $data_port; do
        	iptables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
        done
    elif [ "$web_status" = "disable" ]; then
    	for i in $data_port; do
	        iptables -A INPUT -i $i -p $protocol --dport $port -j DROP
	    done
	else
		for i in $data_port; do
			if [ "$i" = "$web_status" ]; then
				iptables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
			else
				iptables -A INPUT -i $i -p $protocol --dport $port -j DROP
			fi
		done
    fi
}

set_web_access_rules_v6()
{
    # set webaccess permission
    get_port_info $web_port_info
    num=`ip6tables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" | wc -l`
    for i in `seq 1 $num`; do
    	for j in $data_port; do
        	ip6tables -D INPUT -i $j -p $protocol --dport $port -j ACCEPT > /dev/null 2>&1
        	ip6tables -D INPUT -i $j -p $protocol --dport $port -j DROP > /dev/null 2>&1
        done
    done

    if [ "$web_status" = "all" ]; then
    	for i in $data_port; do
        	ip6tables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
        done
    elif [ "$web_status" = "disable" ]; then
    	for i in $data_port; do
	        ip6tables -A INPUT -i $i -p $protocol --dport $port -j DROP
	    done
	else
		for i in $data_port; do
			if [ "$i" = "$web_status" ]; then
				ip6tables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
			else
				ip6tables -A INPUT -i $i -p $protocol --dport $port -j DROP
			fi
		done
    fi
}


set_ssh_access_rules()
{
    # set sshaccess permission
    get_port_info $ssh_port_info
    num=`iptables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" | wc -l`
    for i in `seq 1 $num`; do
    	for j in $data_port; do
	        iptables -D INPUT -i $j -p $protocol --dport $port -j ACCEPT > /dev/null 2>&1
    	    iptables -D INPUT -i $j -p $protocol --dport $port -j DROP > /dev/null 2>&1
    	done
    done

    if [ "$ssh_status" = "all" ]; then
    	for i in $data_port; do
        	iptables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
        done
    elif [ "$ssh_status" = "disable" ]; then
    	for i in $data_port; do
	        iptables -A INPUT -i $i -p $protocol --dport $port -j DROP
	    done
	else
		for i in $data_port; do
			if [ "$i" = "$ssh_status" ]; then
				iptables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
			else
				iptables -A INPUT -i $i -p $protocol --dport $port -j DROP
			fi
		done
    fi
}

set_ssh_access_rules_v6()
{
    # set sshaccess permission
    get_port_info $ssh_port_info
    num=`ip6tables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" | wc -l`
    for i in `seq 1 $num`; do
    	for j in $data_port; do
	        ip6tables -D INPUT -i $j -p $protocol --dport $port -j ACCEPT > /dev/null 2>&1
    	    ip6tables -D INPUT -i $j -p $protocol --dport $port -j DROP > /dev/null 2>&1
    	done
    done

    if [ "$ssh_status" = "all" ]; then
    	for i in $data_port; do
        	ip6tables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
        done
    elif [ "$ssh_status" = "disable" ]; then
    	for i in $data_port; do
	        ip6tables -A INPUT -i $i -p $protocol --dport $port -j DROP
	    done
	else
		for i in $data_port; do
			if [ "$i" = "$ssh_status" ]; then
				iptables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
			else
				iptables -A INPUT -i $i -p $protocol --dport $port -j DROP
			fi
		done
    fi
}


set_postfix_access_rules()
{
    # set permission for process master port
    get_port_info $postfix_port_info
    num=`iptables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" | wc -l`
    for i in `seq 1 $num`; do
        for j in $data_port ; do
            iptables -D INPUT -i $j -p $protocol --dport $port -j DROP > /dev/null 2>&1
        done
    done

    for i in $data_port ; do
        iptables -A INPUT -i $i -p $protocol --dport $port -j DROP
    done
}

set_postfix_access_rules_v6()
{
    # set permission for process master port
    get_port_info $postfix_port_info
    num=`ip6tables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" | wc -l`
    for i in `seq 1 $num`; do
        for j in $data_port ; do
            ip6tables -D INPUT -i $j -p $protocol --dport $port -j DROP > /dev/null 2>&1
        done
    done

    for i in $data_port ; do
        ip6tables -A INPUT -i $i -p $protocol --dport $port -j DROP
    done
}

set_internal_access_rules()
{
    # set permission for internal ports 
    for i in ${trust_ip_list[@]}; do 
        iptables -nxL INPUT | grep -v "grep" | awk '{print $4}' | grep -w "$i" > /dev/null 2>&1
        if [ $? -ne 0 ]; then
            for j in ${internal_fix_port_info_list[@]}; do
                get_port_info $j
                iptables -A INPUT -i $internal_port -p $protocol -s $i --dport $port -j ACCEPT
            done
        fi
    done

    cur_ip_list_in_iptables=`iptables -xnL INPUT | grep -v "source" | awk '{print $4}' | tail -n +2`
    for i in $cur_ip_list_in_iptables; do 
        result=0
        for j in ${trust_ip_list[@]}; do 
            if [ $i = $j ]; then
                result=1
            fi
        done
        if [ $result -eq 0 ]; then
            for k in ${internal_fix_port_info_list[@]}; do
                get_port_info $k 
                iptables -D INPUT -i $internal_port -p $protocol -s $i --dport $port -j ACCEPT > /dev/null 2>&1
            done
        fi
    done
}

set_changeable_port_rules()
{
    # set permission for changeable ports 
    for i in ${changeable_port_info_list[@]}; do
        get_port_info $i
        # Only search the string end with port. Otherwise, if the port 2500 is in rules, then server port 25
        # if will report that the 25 port is there. 
        iptables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" > /dev/null 2>&1
        if [ $? -ne 0 ]; then
        	for i in $data_port ; do
            	iptables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
           	done
        fi
    done

    cur_port_list=`iptables -xnL INPUT | grep "dpt" | awk '{print $7}' | awk -F: '{print$2}' | sort -u`
    for i in $cur_port_list; do
        result=0
        for j in in ${port_info_list[@]}; do
            get_port_info $j
            if [ $i = $port ]; then
                result=1
            fi
        done
        if [ $result -eq 0 ]; then
        	for i in $data_port ; do
            	iptables -D INPUT -i $i -p tcp --dport $i -j ACCEPT > /dev/null 2>&1
            	iptables -D INPUT -i $i -p udp --dport $i -j ACCEPT > /dev/null 2>&1
            done
        fi
    done
}

set_changeable_port_rules_v6()
{
    # set permission for changeable ports 
    for i in ${changeable_port_info_list[@]}; do
        get_port_info $i
        # Only search the string end with port. Otherwise, if the port 2500 is in rules, then server port 25
        # if will report that the 25 port is there. 
        ip6tables -nxL INPUT | grep -v "grep" | grep "$protocol dpt:$port\>" > /dev/null 2>&1
        if [ $? -ne 0 ]; then
        	for i in $data_port ; do
            	ip6tables -A INPUT -i $i -p $protocol --dport $port -j ACCEPT
           	done
        fi
    done

    cur_port_list=`ip6tables -xnL INPUT | grep "dpt" | awk '{print $7}' | awk -F: '{print$2}' | sort -u`
    for i in $cur_port_list; do
        result=0
        for j in in ${port_info_list[@]}; do
            get_port_info $j
            if [ $i = $port ]; then
                result=1
            fi
        done
        if [ $result -eq 0 ]; then
        	for i in $data_port ; do
            	ip6tables -D INPUT -i $i -p tcp --dport $i -j ACCEPT > /dev/null 2>&1
            	ip6tables -D INPUT -i $i -p udp --dport $i -j ACCEPT > /dev/null 2>&1
            done
        fi
    done
}

set_snmp_access_rules()
{
# set snmpacess permission
iptables -I INPUT -p udp --dport 161 -j ACCEPT
}

start()
{ 
    echo -n "Applying firewall rules..."
    
    get_network_info

    set_basic_rules
    set_exposed_fix_port_rules
    set_web_access_rules
    set_ssh_access_rules
    set_postfix_access_rules
    set_internal_access_rules
    set_changeable_port_rules
    set_snmp_access_rules

    set_basic_rules_v6
    set_exposed_fix_port_rules_v6
    set_web_access_rules_v6
    set_ssh_access_rules_v6
    set_postfix_access_rules_v6
    # set_internal_access_rules_v6
    set_changeable_port_rules_v6
    
    echo_success
    echo
}

stop()
{
	echo -n "Dismissing firewall rules..."
	
    iptables -P INPUT ACCEPT
    iptables -P OUTPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -F
    iptables -X

    ip6tables -P INPUT ACCEPT
    ip6tables -P OUTPUT ACCEPT
    ip6tables -P FORWARD ACCEPT
    ip6tables -F
    ip6tables -X
    
    echo_success
    echo
}

reload()
{
	echo -n "Reloading firewall settings..."
    get_network_info

    set_web_access_rules
    set_ssh_access_rules
    set_postfix_access_rules
    set_internal_access_rules
    set_changeable_port_rules

    set_web_access_rules_v6
    set_ssh_access_rules_v6
    set_postfix_access_rules_v6
    set_changeable_port_rules_v6

    update_issue

    echo_success
    echo
}

status()
{
	tables=`cat $PROC_IPTABLES_NAMES 2>/dev/null`
	if [ -z "$tables" ]; then
		echo "Firewall has been stopped"
		exit 3
	else
		echo "Firewall is currently running"
		exit 0
	fi
}

main()
{
    case $1 in
        start)
            start
            ;;
        stop)
            stop
            ;;
        restart)
            stop
            start
            ;;
        reload)
            reload
            ;;
        status)
        	status
        	;;
        *)
            echo "Usage: rcFirewall (start|stop|restart|reload|status)"
            ;;
    esac
}

main $1

# vim:shiftwidth=4:tabstop=4:expandtab:ft=sh
